import { useCallback, useEffect, useRef, useState } from 'react';

type VersionPayload = {
  buildHash?: string;
  timestamp?: string;
};

type UpdateReason = 'version_changed' | 'chunk_load_error';

const DEFAULT_POLL_INTERVAL_MS = 60_000; // 1 min

async function fetchVersion(signal?: AbortSignal): Promise<VersionPayload | null> {
  try {
    const res = await fetch(`/version.json?ts=${Date.now()}`, {
      cache: 'no-store',
      signal,
    });
    if (!res.ok) return null;
    return (await res.json()) as VersionPayload;
  } catch {
    return null;
  }
}

function normalizeVersion(v: VersionPayload | null): string | null {
  if (!v) return null;
  // Prefer buildHash, fallback to timestamp (still good enough to detect rollouts)
  const key = (v.buildHash && String(v.buildHash).trim()) || (v.timestamp && String(v.timestamp).trim());
  return key || null;
}

function isChunkLoadError(err: unknown): boolean {
  const anyErr = err as any;
  const name = anyErr?.name ? String(anyErr.name) : '';
  const message = anyErr?.message ? String(anyErr.message) : '';
  const stack = anyErr?.stack ? String(anyErr.stack) : '';

  // CRA / webpack typical patterns
  return (
    name.includes('ChunkLoadError') ||
    message.includes('ChunkLoadError') ||
    message.includes('Loading chunk') ||
    stack.includes('ChunkLoadError') ||
    stack.includes('Loading chunk')
  );
}

export function useUiUpdate(pollIntervalMs: number = DEFAULT_POLL_INTERVAL_MS) {
  const initialVersionRef = useRef<string | null>(null);
  const [isUpdateAvailable, setIsUpdateAvailable] = useState(false);
  const [reason, setReason] = useState<UpdateReason | null>(null);

  const triggerUpdate = useCallback((r: UpdateReason) => {
    setReason(prev => prev ?? r);
    setIsUpdateAvailable(true);
  }, []);

  const refreshNow = useCallback(() => {
    // Hard reload to ensure HTML + chunks are from the same build
    window.location.reload();
  }, []);

  useEffect(() => {
    let mounted = true;
    const controller = new AbortController();

    const init = async () => {
      const v = await fetchVersion(controller.signal);
      if (!mounted) return;
      initialVersionRef.current = normalizeVersion(v);
    };

    init();

    return () => {
      mounted = false;
      controller.abort();
    };
  }, []);

  useEffect(() => {
    if (isUpdateAvailable) return;

    let timer: number | undefined;
    const controller = new AbortController();

    const tick = async () => {
      // Donâ€™t spam when tab is hidden (mobile battery + less noise)
      if (typeof document !== 'undefined' && document.visibilityState !== 'visible') return;

      const current = normalizeVersion(await fetchVersion(controller.signal));
      const initial = initialVersionRef.current;
      if (initial && current && initial !== current) {
        triggerUpdate('version_changed');
      }
    };

    // Kick once soon after mount, then interval
    timer = window.setInterval(tick, pollIntervalMs);
    window.setTimeout(tick, 5_000);

    const onFocus = () => tick();
    window.addEventListener('focus', onFocus);

    return () => {
      if (timer) window.clearInterval(timer);
      controller.abort();
      window.removeEventListener('focus', onFocus);
    };
  }, [isUpdateAvailable, pollIntervalMs, triggerUpdate]);

  useEffect(() => {
    if (isUpdateAvailable) return;

    const onWindowError = (event: ErrorEvent) => {
      if (isChunkLoadError(event.error)) {
        triggerUpdate('chunk_load_error');
      }
    };

    const onUnhandledRejection = (event: PromiseRejectionEvent) => {
      if (isChunkLoadError(event.reason)) {
        triggerUpdate('chunk_load_error');
      }
    };

    window.addEventListener('error', onWindowError);
    window.addEventListener('unhandledrejection', onUnhandledRejection);

    return () => {
      window.removeEventListener('error', onWindowError);
      window.removeEventListener('unhandledrejection', onUnhandledRejection);
    };
  }, [isUpdateAvailable, triggerUpdate]);

  return {
    isUpdateAvailable,
    reason,
    refreshNow,
  };
}


